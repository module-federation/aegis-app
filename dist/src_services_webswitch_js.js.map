{"version":3,"sources":["webpack://microlib-example/./src/services/webswitch.js"],"names":["FQDN","process","env","WEBSWITCH_HOST","PORT","PATH","getHostName","dns","address","console","log","warn","webswitchClient","publishEvent","event","observer","useWebswitch","hostname","serializedEvent","JSON","stringify","webswitch","debug","WebSocket","on","message","parse","notify","eventName","send","e","name"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACa;;;;;;AAEb;AACA;AACA;AACA;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAACC,GAAR,CAAYC,cAAZ,IAA8B,qBAA3C;AACA,IAAMC,IAAI,GAAG,IAAb;AACA,IAAMC,IAAI,GAAG,cAAb;;SAEeC,W;;;AAWf;;;;yEAXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBAEkBC,0DAAA,CAAWP,IAAX,CAFlB;;AAAA;AAAA,iBAEoC,UAAAQ,OAAO;AAAA,qBAAIC,OAAO,CAACC,GAAR,CAAYF,OAAZ,CAAJ;AAAA,aAF3C;AAAA;AAAA;AAAA;;AAAA,0BAGQR,IAHR;AAAA;AAAA;;AAAA;AAAA,0BAIQ,WAJR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAMIS,mBAAO,CAACE,IAAR,CAAa,YAAb;;AANJ;AAAA,6CAQS,WART;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAYA,IAAIC,eAAJ;AAEO,SAAeC,YAAtB;AAAA;AAAA,C,CA0CA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;0EAtGO,kBAA4BC,KAA5B,EAAmCC,QAAnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA6CC,wBAA7C,8DAA4D,IAA5D;;AAAA,gBACAF,KADA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA,mBAGkBR,WAAW,EAH7B;;AAAA;AAGCW,oBAHD;AAICC,2BAJD,GAImBC,IAAI,CAACC,SAAL,CAAeN,KAAf,CAJnB;;AAML,gBAAI;AACOO,uBADP,GACF,SAASA,SAAT,GAAqB;AACnBZ,uBAAO,CAACa,KAAR,CAAc,SAAd,EAAyBR,KAAzB;;AAEA,oBAAI,CAACF,eAAL,EAAsB;AACpBA,iCAAe,GAAG,IAAIW,2CAAJ,gBAAsBN,QAAtB,cAAkCb,IAAlC,SAAyCC,IAAzC,EAAlB,CADoB,CAGpB;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEAO,iCAAe,CAACY,EAAhB,CAAmB,SAAnB,EAA8B,UAAUC,OAAV,EAAmB;AAC/C,wBAAMX,KAAK,GAAGK,IAAI,CAACO,KAAL,CAAWD,OAAX,CAAd;AACAhB,2BAAO,CAACa,KAAR,CAAcG,OAAd;AACAV,4BAAQ,CAACY,MAAT,CAAgBb,KAAK,CAACc,SAAtB,EAAiCd,KAAjC;AACD,mBAJD;AAKD;;AAEDF,+BAAe,CAACiB,IAAhB,CAAqBX,eAArB;AACD,eA7BC;;AA8BFG,uBAAS;AACV,aA/BD,CA+BE,OAAOS,CAAP,EAAU;AACVrB,qBAAO,CAACE,IAAR,CAAaE,YAAY,CAACkB,IAA1B,EAAgCD,CAAC,CAACL,OAAlC;AACD;;AAvCI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","file":"src_services_webswitch_js.js","sourcesContent":["/**\n * WEBSWITCH (c)\n * websocket clients connect to a common server,\n * which broadcasts any messages it receives.\n */\n\"use strict\";\n\nimport WebSocket from \"ws\";\nimport dns from \"dns/promises\";\nimport http from \"http\";\nimport https from \"https\";\n\nconst FQDN = process.env.WEBSWITCH_HOST || \"webswitch.aegis.dev\";\nconst PORT = 8062;\nconst PATH = \"/api/publish\";\n\nasync function getHostName() {\n  try {\n    return (await dns.lookup(FQDN), address => console.log(address))\n      ? FQDN\n      : \"localhost\";\n  } catch (error) {\n    console.warn(\"dns lookup\", error);\n  }\n  return \"localhost\";\n}\n\n/**@type import(\"ws/lib/websocket\") */\nlet webswitchClient;\n\nexport async function publishEvent(event, observer, useWebswitch = true) {\n  if (!event) return;\n\n  const hostname = await getHostName();\n  const serializedEvent = JSON.stringify(event);\n\n  try {\n    function webswitch() {\n      console.debug(\"sending\", event);\n\n      if (!webswitchClient) {\n        webswitchClient = new WebSocket(`ws://${hostname}:${PORT}${PATH}`);\n\n        // setTimeout(() => {\n        //   webswitchClient.ping();\n        // }, 30000);\n\n        // const timerId = setTimeout(() => {\n        //   webswitchClient.terminate();\n        //   webswitch();\n        // }, 60000);\n\n        // webswitchClient.on(\"pong\", function () {\n        //   clearTimeout(timerId);\n        //   setTimeout(() => webswitchClient.ping(), 30000);\n        // });\n\n        webswitchClient.on(\"message\", function (message) {\n          const event = JSON.parse(message);\n          console.debug(message);\n          observer.notify(event.eventName, event);\n        });\n      }\n\n      webswitchClient.send(serializedEvent);\n    }\n    webswitch();\n  } catch (e) {\n    console.warn(publishEvent.name, e.message);\n  }\n}\n\n// function getHeaders(method, payload) {\n//   const contentLength = [\"POST\", \"PATCH\"].includes(method)\n//     ? Buffer.byteLength(payload)\n//     : 0;\n\n//   const contentHeaders = { \"Content-Type\": \"application/json\" };\n\n//   return contentLength > 0\n//     ? { ...contentHeaders, \"Content-Length\": contentLength }\n//     : contentHeaders;\n// }\n\n// async function httpsClient({\n//   hostname,\n//   port,\n//   path,\n//   protocol = \"https\",\n//   method = \"GET\",\n//   payload = \"\",\n//   safe = true,\n// }) {\n//   return new Promise(function (resolve, reject) {\n//     const normal = {\n//       hostname,\n//       port,\n//       path,\n//       method,\n//       headers: getHeaders(method, payload),\n//     };\n\n//     const options = safe ? normal : { ...normal, rejectUnauthorized: false };\n//     const chunks = [];\n//     const client = {\n//       http: http,\n//       https: https,\n//     };\n\n//     try {\n//       const req = client[protocol].request(options, res => {\n//         res.setEncoding(\"utf8\");\n//         res.on(\"data\", chunk => chunks.push(chunk));\n//         res.on(\"error\", e => console.warn(httpsClient.name, e.message));\n//         res.on(\"end\", () => resolve(chunks.join(\"\")));\n//       });\n//       req.on(\"error\", e => reject(e));\n//       if (payload) req.on(\"connect\", () => req.write(payload));\n//     } catch (e) {\n//       console.warn(httpsClient.name, e.message);\n//     }\n//   });\n// }\n\n// else {\n//   httpsClient({\n//     hostname,\n//     port,\n//     path,\n//     method: \"POST\",\n//     payload: serialziedEvent,\n//   });\n// }\n"],"sourceRoot":""}